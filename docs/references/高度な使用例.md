import { EntryPointCallGraphAnalyzer } from './EntryPointCallGraphAnalyzer';

// ã‚«ã‚¹ã‚¿ãƒ è¨­å®šã‚ªãƒ—ã‚·ãƒ§ãƒ³
interface AnalyzerOptions {
  // è§£æã‹ã‚‰é™¤å¤–ã™ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³
  excludePatterns?: RegExp[];
  // ç‰¹å®šã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã¿å«ã‚ã‚‹
  includeModules?: string[];
  // éåŒæœŸå‘¼ã³å‡ºã—ã®ã¿è¿½è·¡
  asyncOnly?: boolean;
  // ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’åé›†
  collectMetrics?: boolean;
}

// æ‹¡å¼µç‰ˆã‚¢ãƒŠãƒ©ã‚¤ã‚¶ãƒ¼
class ExtendedCallGraphAnalyzer extends EntryPointCallGraphAnalyzer {
  private options: AnalyzerOptions;

  constructor(tsConfigPath: string, maxDepth: number, options: AnalyzerOptions = {}) {
    super(tsConfigPath, maxDepth);
    this.options = options;
  }

  // ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°æ©Ÿèƒ½ã‚’è¿½åŠ 
  protected shouldAnalyzeCall(targetPath: string, callType: string): boolean {
    // é™¤å¤–ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ãƒã‚§ãƒƒã‚¯
    if (this.options.excludePatterns) {
      for (const pattern of this.options.excludePatterns) {
        if (pattern.test(targetPath)) {
          return false;
        }
      }
    }

    // å«ã‚ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æŒ‡å®š
    if (this.options.includeModules) {
      const included = this.options.includeModules.some(module => 
        targetPath.includes(module)
      );
      if (!included) return false;
    }

    // éåŒæœŸã®ã¿ãƒ¢ãƒ¼ãƒ‰
    if (this.options.asyncOnly && callType === 'sync') {
      return false;
    }

    return true;
  }

  // ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†
  collectMetrics(graph: CallGraph): CallGraphMetrics {
    const metrics: CallGraphMetrics = {
      totalFunctions: graph.nodes.size,
      totalCalls: graph.edges.length,
      asyncFunctions: 0,
      maxCallDepth: 0,
      averageFanOut: 0,
      circularDependencies: [],
      hotspots: []
    };

    // éåŒæœŸé–¢æ•°ã®ã‚«ã‚¦ãƒ³ãƒˆ
    for (const node of graph.nodes.values()) {
      if (node.async) metrics.asyncFunctions++;
    }

    // ãƒ•ã‚¡ãƒ³ã‚¢ã‚¦ãƒˆï¼ˆå„é–¢æ•°ã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã‚‹é–¢æ•°ã®æ•°ï¼‰ã®è¨ˆç®—
    const fanOuts = new Map<string, number>();
    for (const edge of graph.edges) {
      fanOuts.set(edge.source, (fanOuts.get(edge.source) || 0) + 1);
    }
    
    if (fanOuts.size > 0) {
      const totalFanOut = Array.from(fanOuts.values()).reduce((a, b) => a + b, 0);
      metrics.averageFanOut = totalFanOut / fanOuts.size;
    }

    // ãƒ›ãƒƒãƒˆã‚¹ãƒãƒƒãƒˆï¼ˆå¤šãã®å ´æ‰€ã‹ã‚‰å‘¼ã°ã‚Œã‚‹é–¢æ•°ï¼‰ã®æ¤œå‡º
    const callCounts = new Map<string, number>();
    for (const edge of graph.edges) {
      callCounts.set(edge.target, (callCounts.get(edge.target) || 0) + 1);
    }
    
    metrics.hotspots = Array.from(callCounts.entries())
      .filter(([_, count]) => count > 3)
      .sort((a, b) => b[1] - a[1])
      .map(([nodeId, count]) => ({
        function: graph.nodes.get(nodeId)?.name || nodeId,
        callCount: count
      }));

    // å¾ªç’°ä¾å­˜ã®æ¤œå‡º
    metrics.circularDependencies = this.detectCircularDependencies(graph);

    return metrics;
  }

  // å¾ªç’°ä¾å­˜ã®æ¤œå‡º
  private detectCircularDependencies(graph: CallGraph): string[][] {
    const cycles: string[][] = [];
    const visited = new Set<string>();
    const recursionStack = new Set<string>();

    const dfs = (nodeId: string, path: string[]): void => {
      visited.add(nodeId);
      recursionStack.add(nodeId);

      const edges = graph.edges.filter(e => e.source === nodeId);
      for (const edge of edges) {
        if (!visited.has(edge.target)) {
          dfs(edge.target, [...path, edge.target]);
        } else if (recursionStack.has(edge.target)) {
          const cycleStart = path.indexOf(edge.target);
          if (cycleStart !== -1) {
            cycles.push(path.slice(cycleStart));
          }
        }
      }

      recursionStack.delete(nodeId);
    };

    for (const nodeId of graph.nodes.keys()) {
      if (!visited.has(nodeId)) {
        dfs(nodeId, [nodeId]);
      }
    }

    return cycles;
  }

  // Mermaidå›³ã®ç”Ÿæˆï¼ˆæ”¹è‰¯ç‰ˆï¼‰
  generateMermaidDiagram(graph: CallGraph): string {
    const lines: string[] = ['graph TD'];
    
    // ãƒãƒ¼ãƒ‰ã®ã‚¹ã‚¿ã‚¤ãƒªãƒ³ã‚°
    const nodeStyles: string[] = [];
    let styleIndex = 0;

    // ãƒãƒ¼ãƒ‰ã®å®šç¾©
    for (const [id, node] of graph.nodes) {
      const safeName = node.name.replace(/[^a-zA-Z0-9]/g, '_');
      const label = `${node.name}\\n${node.type}`;
      
      if (node.async) {
        lines.push(`    ${safeName}["${label}"]`);
        nodeStyles.push(`    style ${safeName} fill:#f9f,stroke:#333,stroke-width:2px`);
      } else {
        lines.push(`    ${safeName}("${label}")`);
      }
    }

    // ã‚¨ãƒƒã‚¸ã®å®šç¾©
    const edgeMap = new Map<string, number>();
    for (const edge of graph.edges) {
      const sourceNode = graph.nodes.get(edge.source);
      const targetNode = graph.nodes.get(edge.target);
      
      if (sourceNode && targetNode) {
        const sourceName = sourceNode.name.replace(/[^a-zA-Z0-9]/g, '_');
        const targetName = targetNode.name.replace(/[^a-zA-Z0-9]/g, '_');
        const edgeKey = `${sourceName}-${targetName}`;
        
        // é‡è¤‡ã‚¨ãƒƒã‚¸ã®ã‚«ã‚¦ãƒ³ãƒˆ
        edgeMap.set(edgeKey, (edgeMap.get(edgeKey) || 0) + 1);
        
        const arrow = edge.type === 'async' ? '-.->>' : '-->';
        const label = edgeMap.get(edgeKey)! > 1 ? `|${edgeMap.get(edgeKey)}x|` : '';
        
        lines.push(`    ${sourceName} ${arrow}${label} ${targetName}`);
      }
    }

    // ã‚¹ã‚¿ã‚¤ãƒ«ã®é©ç”¨
    lines.push(...nodeStyles);

    return lines.join('\n');
  }

  // GraphViz DOTå½¢å¼ã®ç”Ÿæˆ
  generateDotDiagram(graph: CallGraph): string {
    const lines: string[] = [
      'digraph CallGraph {',
      '    rankdir=LR;',
      '    node [shape=box];',
      ''
    ];

    // ãƒãƒ¼ãƒ‰ã®å®šç¾©
    for (const [id, node] of graph.nodes) {
      const attributes: string[] = [
        `label="${node.name}\\n${node.type}"`,
      ];
      
      if (node.async) {
        attributes.push('style=filled', 'fillcolor=lightblue');
      }
      
      if (id === graph.entryPoint) {
        attributes.push('shape=ellipse', 'style=bold');
      }
      
      lines.push(`    "${id}" [${attributes.join(', ')}];`);
    }

    lines.push('');

    // ã‚¨ãƒƒã‚¸ã®å®šç¾©
    for (const edge of graph.edges) {
      const attributes: string[] = [];
      
      if (edge.type === 'async') {
        attributes.push('style=dashed');
      } else if (edge.type === 'callback') {
        attributes.push('style=dotted');
      }
      
      const attrString = attributes.length > 0 ? ` [${attributes.join(', ')}]` : '';
      lines.push(`    "${edge.source}" -> "${edge.target}"${attrString};`);
    }

    lines.push('}');
    return lines.join('\n');
  }
}

// ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®šç¾©
interface CallGraphMetrics {
  totalFunctions: number;
  totalCalls: number;
  asyncFunctions: number;
  maxCallDepth: number;
  averageFanOut: number;
  circularDependencies: string[][];
  hotspots: Array<{
    function: string;
    callCount: number;
  }>;
}

// ä½¿ç”¨ä¾‹
async function analyzeWithOptions() {
  const analyzer = new ExtendedCallGraphAnalyzer('./tsconfig.json', 8, {
    excludePatterns: [/\.test\.ts$/, /\.spec\.ts$/],
    includeModules: ['src/services', 'src/controllers'],
    asyncOnly: false,
    collectMetrics: true
  });

  // APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®è§£æ
  const graph = await analyzer.analyzeFromEntryPoint(
    'src/controllers/UserController.ts',
    'handleCreateUser',
    'UserController'
  );

  // ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®åé›†
  const metrics = analyzer.collectMetrics(graph);
  console.log('Metrics:', metrics);

  // å¾ªç’°ä¾å­˜ã®è­¦å‘Š
  if (metrics.circularDependencies.length > 0) {
    console.warn('âš ï¸  Circular dependencies detected:');
    metrics.circularDependencies.forEach(cycle => {
      console.warn(`   ${cycle.join(' â†’ ')}`);
    });
  }

  // ãƒ›ãƒƒãƒˆã‚¹ãƒãƒƒãƒˆã®è¡¨ç¤º
  if (metrics.hotspots.length > 0) {
    console.log('\nğŸ”¥ Hotspots (frequently called functions):');
    metrics.hotspots.forEach(({ function: func, callCount }) => {
      console.log(`   ${func}: called ${callCount} times`);
    });
  }

  // è¦–è¦šåŒ–
  const mermaidDiagram = analyzer.generateMermaidDiagram(graph);
  const dotDiagram = analyzer.generateDotDiagram(graph);

  // ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
  import * as fs from 'fs';
  fs.writeFileSync('callgraph.mmd', mermaidDiagram);
  fs.writeFileSync('callgraph.dot', dotDiagram);
  
  console.log('\nâœ… Analysis complete!');
  console.log('   - Mermaid diagram: callgraph.mmd');
  console.log('   - GraphViz diagram: callgraph.dot');
}

// ãƒãƒƒãƒå‡¦ç†ã®ä¾‹
async function batchAnalyzeEndpoints() {
  const analyzer = new ExtendedCallGraphAnalyzer('./tsconfig.json', 5);
  
  // è¤‡æ•°ã®ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆã‚’å®šç¾©
  const endpoints = [
    { path: 'src/api/users.ts', func: 'createUser' },
    { path: 'src/api/users.ts', func: 'updateUser' },
    { path: 'src/api/auth.ts', func: 'login' },
    { path: 'src/api/auth.ts', func: 'logout' },
  ];

  const results = new Map<string, CallGraph>();

  for (const endpoint of endpoints) {
    try {
      const graph = await analyzer.analyzeFromEntryPoint(
        endpoint.path,
        endpoint.func
      );
      results.set(`${endpoint.path}#${endpoint.func}`, graph);
    } catch (error) {
      console.error(`Failed to analyze ${endpoint.func}:`, error);
    }
  }

  // çµ±åˆãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ
  generateCombinedReport(results);
}

function generateCombinedReport(results: Map<string, CallGraph>) {
  let report = '# Combined Call Graph Analysis Report\n\n';
  
  for (const [endpoint, graph] of results) {
    report += `## ${endpoint}\n\n`;
    report += `- Total functions: ${graph.nodes.size}\n`;
    report += `- Total calls: ${graph.edges.length}\n\n`;
  }
  
  // å…±é€šã®é–¢æ•°ã‚’è¦‹ã¤ã‘ã‚‹
  const functionUsage = new Map<string, string[]>();
  
  for (const [endpoint, graph] of results) {
    for (const nodeId of graph.nodes.keys()) {
      if (!functionUsage.has(nodeId)) {
        functionUsage.set(nodeId, []);
      }
      functionUsage.get(nodeId)!.push(endpoint);
    }
  }
  
  report += '## Shared Functions\n\n';
  for (const [func, endpoints] of functionUsage) {
    if (endpoints.length > 1) {
      report += `- ${func}: used by ${endpoints.join(', ')}\n`;
    }
  }
  
  return report;
}

// å®Ÿè¡Œ
analyzeWithOptions().catch(console.error);